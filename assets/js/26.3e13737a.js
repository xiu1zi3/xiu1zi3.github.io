(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{353:function(t,a,s){"use strict";s.r(a);var v=s(8),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#线程安全问题产生的前提"}},[t._v("线程安全问题产生的前提")])]),a("li",[a("a",{attrs:{href:"#避免线程安全问题"}},[t._v("避免线程安全问题")])]),a("li",[a("a",{attrs:{href:"#同步编程模型"}},[t._v("同步编程模型")])]),a("li",[a("a",{attrs:{href:"#异步编程模型"}},[t._v("异步编程模型")])])])]),a("p"),t._v(" "),a("h3",{attrs:{id:"线程安全问题产生的前提"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程安全问题产生的前提"}},[t._v("#")]),t._v(" 线程安全问题产生的前提")]),t._v(" "),a("p",[t._v("例子：2 人在同 1 个余额 10000 元的账户中，分别取走 10000 元钱")]),t._v(" "),a("p",[t._v("条件1：多线程并发。")]),t._v(" "),a("p",[t._v("条件2：有共享数据。")]),t._v(" "),a("p",[t._v("条件3：共享数据有修改的行为。")]),t._v(" "),a("h3",{attrs:{id:"避免线程安全问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免线程安全问题"}},[t._v("#")]),t._v(" 避免线程安全问题")]),t._v(" "),a("p",[t._v("线程排队执行。（不能并发），用排队执行解决线程安全问题。")]),t._v(" "),a("p",[t._v("这种机制被称为：线程同步机制。")]),t._v(" "),a("h3",{attrs:{id:"同步编程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步编程模型"}},[t._v("#")]),t._v(" 同步编程模型")]),t._v(" "),a("p",[t._v("同步编程模型：")]),t._v(" "),a("p",[t._v("线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型。\n效率较低。线程排队执行")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("自己的理解")]),t._v(" "),a("p",[t._v("一句话：避免对同一份数据的同时操作\n不让多个线程同时去操作一份共享数据,而是让线程对统一数据的处理要排队,当一个线程执行结束之后另外一个线程才可以执行！")])]),t._v(" "),a("h3",{attrs:{id:"异步编程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步编程模型"}},[t._v("#")]),t._v(" 异步编程模型")]),t._v(" "),a("p",[t._v("异步编程模型：")]),t._v(" "),a("p",[t._v("线程和线程t2，各自执行各自的，t1不管t2，t2不管t，谁也不需要等谁，这种编程模型叫做：异步编程模型。\n其实就是：多线程并发（效率较高。")])])}),[],!1,null,null,null);a.default=_.exports}}]);