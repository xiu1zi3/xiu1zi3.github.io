(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{344:function(v,_,t){"use strict";t.r(_);var a=t(8),i=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"juc-是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#juc-是什么"}},[v._v("#")]),v._v(" JUC 是什么")]),v._v(" "),_("p",[v._v("JUC 是 java.util.concurrent 包的简称，在 Java5.0 添加")]),v._v(" "),_("p",[v._v("JUC包是为了更好的支持高并发任务，具体来说，让做多线程编程时减少竞争条件和死锁的问题")]),v._v(" "),_("h3",{attrs:{id:"java-并发学习路线"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-并发学习路线"}},[v._v("#")]),v._v(" Java 并发学习路线")]),v._v(" "),_("ul",[_("li",[v._v("进程")]),v._v(" "),_("li",[v._v("线程")]),v._v(" "),_("li",[_("strong",[v._v("并发的共享模型")]),v._v(" "),_("ul",[_("li",[v._v("管程(Monitor)-悲观锁-阻塞")]),v._v(" "),_("li",[v._v("java 内存模型(JMM)")]),v._v(" "),_("li",[v._v("无锁并发-乐观锁-非阻塞")]),v._v(" "),_("li",[v._v("并发工具\n"),_("ul",[_("li",[v._v("线程池")]),v._v(" "),_("li",[v._v("JUC")]),v._v(" "),_("li",[v._v("第三方并发工具比如 disruptor, guava 等")])])])])]),v._v(" "),_("li",[v._v("应用\n"),_("ul",[_("li",[v._v("提升效率")]),v._v(" "),_("li",[v._v("限流")]),v._v(" "),_("li",[v._v("同步")]),v._v(" "),_("li",[v._v("异步")]),v._v(" "),_("li",[v._v("缓存")]),v._v(" "),_("li",[v._v("队列")]),v._v(" "),_("li",[v._v("分治方法")]),v._v(" "),_("li",[v._v("统筹方法")])])]),v._v(" "),_("li",[_("strong",[v._v("并发的非共享模型")]),v._v(" "),_("ul",[_("li",[v._v("私有")]),v._v(" "),_("li",[v._v("弱一致性\n"),_("ul",[_("li",[v._v("akka")])])])])]),v._v(" "),_("li",[v._v("并行\n"),_("ul",[_("li",[v._v("函数式编程")]),v._v(" "),_("li",[v._v("并行编程\n"),_("ul",[_("li",[v._v("映射")]),v._v(" "),_("li",[v._v("归约")])])])])])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("悲观锁")]),v._v(" "),_("p",[_("strong",[v._v("悲观锁")]),v._v("假定会有并发访问，因此在访问共享资源之前先获取锁。在 Java 中，synchronized 关键字和 ReentrantLock 都是悲观锁的实现方式。当一个线程获取了锁，其他线程就会被阻塞，直到持有锁的线程释放锁。")])]),v._v(" "),_("div",{staticClass:"custom-block note"},[_("p",{staticClass:"custom-block-title"},[v._v("阻塞")]),v._v(" "),_("p",[_("strong",[v._v("阻塞")]),v._v("指的是线程在访问共享资源时被挂起，直到某些条件满足后才能继续执行。在 Java 中，使用 synchronized 关键字或者 ReentrantLock 进行同步时，如果获取锁失败，线程会进入阻塞状态，直到获取到锁为止。")])]),v._v(" "),_("h3",{attrs:{id:"管程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#管程"}},[v._v("#")]),v._v(" 管程")]),v._v(" "),_("p",[_("strong",[v._v("管程")]),v._v(" 是一种并发编程的抽象概念，用于控制多个线程对共享资源的访问。在 Java 中，synchronized 关键字可以用来实现管程，通过对方法或代码块进行同步，确保同一时间只有一个线程可以访问共享资源")]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("Monitor")]),v._v(" 是一种用于实现 "),_("strong",[v._v("管程")]),v._v(" 的机制，通常与悲观锁和阻塞相联系。Java 中的每个对象都有一个关联的 Monitor，它负责管理对象的同步和并发访问。当一个线程进入 synchronized 方法或代码块时，它会尝试获取对象的 Monitor，如果获取失败就会进入阻塞状态，直到获取到 Monitor 才能继续执行。")])])])}),[],!1,null,null,null);_.default=i.exports}}]);