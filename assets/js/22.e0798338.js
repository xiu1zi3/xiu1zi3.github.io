(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{351:function(t,a,s){"use strict";s.r(a);var r=s(8),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#线程的-5-种状态"}},[t._v("线程的 5 种状态")])]),a("li",[a("a",{attrs:{href:"#就绪状态"}},[t._v("就绪状态")])]),a("li",[a("a",{attrs:{href:"#运行状态"}},[t._v("运行状态")])])])]),a("p"),t._v(" "),a("p",[a("strong",[t._v("承前启后")])]),t._v(" "),a("p",[t._v("注意到，以上 2 种方式：\n继承 Thread 类+重写它的 run 方法\n创建实现了 Runnable 接口的类+重写它的 run 方法")]),t._v(" "),a("h3",{attrs:{id:"线程的-5-种状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程的-5-种状态"}},[t._v("#")]),t._v(" 线程的 5 种状态")]),t._v(" "),a("p",[a("strong",[t._v("新建")]),t._v("状态就当做出生 ，"),a("strong",[t._v("死亡")]),t._v("状态顾名思义就是死亡\n"),a("strong",[t._v("就绪、执行、阻塞")])]),t._v(" "),a("p",[t._v("一个生命周期大致是：1.新建状态->2.就绪状态与死亡状态交替->3.死亡状态")]),t._v(" "),a("div",{staticClass:"language-mermaid extra-class"},[a("pre",{pre:!0,attrs:{class:"language-mermaid"}},[a("code",[t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("flowchart")]),t._v(" LR\n      A"),a("span",{pre:!0,attrs:{class:"token text string"}},[t._v('["新建状态"]')]),t._v("\n      B"),a("span",{pre:!0,attrs:{class:"token text string"}},[t._v('["就绪状态"]')]),t._v("\n      C"),a("span",{pre:!0,attrs:{class:"token text string"}},[t._v('["运行状态"]')]),t._v("\n      D"),a("span",{pre:!0,attrs:{class:"token text string"}},[t._v('["死亡状态"]')]),t._v("\n      E"),a("span",{pre:!0,attrs:{class:"token text string"}},[t._v('["阻塞状态"]')]),t._v("\n      A "),a("span",{pre:!0,attrs:{class:"token inter-arrow-label"}},[a("span",{pre:!0,attrs:{class:"token arrow-head arrow operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token label property"}},[t._v("调用start方法")]),a("span",{pre:!0,attrs:{class:"token arrow operator"}},[t._v("--\x3e")])]),t._v(" B\n      "),a("span",{pre:!0,attrs:{class:"token arrow operator"}},[t._v("<--")]),t._v("JVM的调度 "),a("span",{pre:!0,attrs:{class:"token arrow operator"}},[t._v("--\x3e")]),t._v(" C "),a("span",{pre:!0,attrs:{class:"token inter-arrow-label"}},[a("span",{pre:!0,attrs:{class:"token arrow-head arrow operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token label property"}},[t._v("run方法结束")]),a("span",{pre:!0,attrs:{class:"token arrow operator"}},[t._v("--\x3e")])]),t._v(" D\n      C"),a("span",{pre:!0,attrs:{class:"token inter-arrow-label"}},[a("span",{pre:!0,attrs:{class:"token arrow-head arrow operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token label property"}},[t._v("遇到阻塞事件（接收用户键盘输入、sleep方法等）")]),a("span",{pre:!0,attrs:{class:"token arrow operator"}},[t._v("--\x3e")])]),t._v("E\n      E"),a("span",{pre:!0,attrs:{class:"token inter-arrow-label"}},[a("span",{pre:!0,attrs:{class:"token arrow-head arrow operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token label property"}},[t._v("阻塞解除")]),a("span",{pre:!0,attrs:{class:"token arrow operator"}},[t._v("--\x3e")])]),t._v("B\n")])])]),a("h3",{attrs:{id:"就绪状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#就绪状态"}},[t._v("#")]),t._v(" 就绪状态")]),t._v(" "),a("p",[t._v("处于"),a("strong",[t._v("新建状态")]),t._v("的线程，调用 start 方法后进入"),a("strong",[t._v("就绪状态")])]),t._v(" "),a("blockquote",[a("p",[t._v("新建状态：刚 new 出来的线程对象（这个状态就无所谓）")])]),t._v(" "),a("p",[a("strong",[t._v("就绪状态")]),t._v("也叫可运行状态： 当前线程具有抢夺 CPU 时间片的权利")]),t._v(" "),a("blockquote",[a("p",[t._v("CPU 时间片就是 CPU 执行权")])]),t._v(" "),a("blockquote",[a("p",[t._v("计算机将"),a("strong",[t._v("存储")]),t._v("(Storage)、"),a("strong",[t._v("算术逻辑单元")]),t._v("(Arithmetic Logic Unit)和"),a("strong",[t._v("控制单元")]),t._v("(Control Unit)三个部分合称为中央处理器（CPU），再加上"),a("strong",[t._v("输入设备")]),t._v("(Input Devices)和"),a("strong",[t._v("输出设备")]),t._v("(Output Devices)就组成了计算机硬件系统。")])]),t._v(" "),a("p",[t._v("寄存器属于 CPU 的"),a("strong",[t._v("存储")]),t._v("部分。寄存器是一种非常快速的临时存储器件")]),t._v(" "),a("h3",{attrs:{id:"运行状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行状态"}},[t._v("#")]),t._v(" 运行状态")]),t._v(" "),a("blockquote",[a("p",[t._v("回忆：传说中“就绪状态与死亡状态交替”，表现为：主线程和分支线程打印顺序有先有后；连续的打印有多有少")])]),t._v(" "),a("p",[t._v("run 方法执行，则线程进入"),a("strong",[t._v("运行状态")])]),t._v(" "),a("p",[t._v("run 方法的开始执行标志着这个线程进入运行状态")]),t._v(" "),a("p",[t._v("如果 CPU 时间片用完了，但 run 方法没有执行完，线程不会死亡，而是返回就绪状态，继续抢夺 CPU 时间片")]),t._v(" "),a("p",[t._v("当再次抢到 CPU 时间之后，会重新进入 run 方法接着上一次的代码继续往下执行。")]),t._v(" "),a("p",[t._v("伪代码：")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("run方法没有执行完"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CPU")]),t._v("时间片没有用完"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        线程进入运行状态，执行run方法，消耗自己占用的"),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CPU")]),t._v("时间片\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CPU")]),t._v("时间片没有了"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CPU")]),t._v("时间片没有抢到"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        线程返回就绪状态，给自己抢"),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CPU")]),t._v("时间片\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("简单地说：\n有心急的猴子。在没填饱肚子的情况下，它有 2 个反射：\n如果手头有香蕉，直接吃香蕉，而不去找香蕉\n如果手头没香蕉，会去找香蕉，得到若干香蕉就开吃。")]),t._v(" "),a("p",[t._v("注意，谁抢到是随机的。一小段执行状态完了回到就绪状态，接着还能抢到，接着执行！")]),t._v(" "),a("p",[t._v("这是“有多有少”的原因之一！")]),t._v(" "),a("blockquote",[a("p",[t._v("拓展：java 的线程调度模型属于“抢占式”。一些语言的线程调度模型属于“均分式”，这些语言对 CPU 时间片是平均分配的")])]),t._v(" "),a("blockquote",[a("p",[t._v("在锁池当中的等待不是 5 种状态以外的状态，最接近的是其中的"),a("strong",[t._v("阻塞状态")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);