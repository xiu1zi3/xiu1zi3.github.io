(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{345:function(v,a,_){"use strict";_.r(a);var t=_(8),e=Object(t.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#方法区内存-静态变量"}},[v._v("方法区内存（静态变量）")])]),a("li",[a("a",{attrs:{href:"#栈内存-局部变量"}},[v._v("栈内存（局部变量）")])]),a("li",[a("a",{attrs:{href:"#堆内存-实例变量"}},[v._v("堆内存（实例变量）")])]),a("li",[a("a",{attrs:{href:"#java-内存管理"}},[v._v("Java 内存管理")])])])]),a("p"),v._v(" "),a("blockquote",[a("p",[v._v("静态变量在方法区；局部变量在栈内存；实例变量在堆内存")]),v._v(" "),a("p",[v._v("详见后面 JUC ：栈可能有多个，有主栈也有分支栈，不同的栈不共享局部变量。堆内存、方法区是所有线程共享的，所以实例变量存在线程安全问题")])]),v._v(" "),a("p",[v._v("Java 内存管理是 Java 虚拟机（JVM）的一个核心部分，它负责分配和管理内存")]),v._v(" "),a("p",[v._v("Java 内存可以大致分为堆空间、栈空间和方法区三个主要部分")]),v._v(" "),a("h2",{attrs:{id:"方法区内存-静态变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法区内存-静态变量"}},[v._v("#")]),v._v(" 方法区内存（静态变量）")]),v._v(" "),a("p",[v._v("方法区（Method Area）有："),a("strong",[v._v("静态变量")]),v._v("、"),a("strong",[v._v("class 字节码代码片段")]),v._v("\n作用：方法区是一个"),a("strong",[v._v("所有线程共享的内存区域")]),v._v("，类加载的时候，"),a("strong",[v._v("class")]),v._v(" 字节码代码片段加载在方法区")]),v._v(" "),a("blockquote",[a("p",[v._v("方法区在 Java 8 及之前被实现为永久代（PermGen），从 Java 8 开始，方法区的实现被称为元空间（Metaspace）。")])]),v._v(" "),a("blockquote",[a("p",[v._v("管理：方法区（或元空间）的垃圾收集主要关注卸载类和回收常量池条目。类可以被卸载，前提是该类的所有实例已经被回收，且该类的 ClassLoader 已经被回收。")])]),v._v(" "),a("h2",{attrs:{id:"栈内存-局部变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈内存-局部变量"}},[v._v("#")]),v._v(" 栈内存（局部变量）")]),v._v(" "),a("p",[a("strong",[v._v("方法代码片段")]),v._v("执行的时候，会给该方法分配内存空间，在栈内存中压栈。"),a("strong",[v._v("栈内存")]),v._v("通常比堆内存小得多。有多少个 Java 线程，就有多少个栈")]),v._v(" "),a("blockquote",[a("p",[v._v("如果递归调用或方法调用的层次太深，可能会导致栈溢出（StackOverflowError）")])]),v._v(" "),a("blockquote",[a("p",[v._v("管理：不需要垃圾收集。当一个方法被调用时，一个新的栈帧（Stack Frame）会被创建并压入栈中；当方法调用结束时，这个栈帧会被销毁。这个过程是自动进行的，不需要垃圾收集。")])]),v._v(" "),a("h2",{attrs:{id:"堆内存-实例变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆内存-实例变量"}},[v._v("#")]),v._v(" 堆内存（实例变量）")]),v._v(" "),a("p",[v._v("作用：堆内存存储所有的对象。所有对象实例（当然包含了实例变量），都存储在同一个堆内存中。是 Java 虚拟机管理的最大一块内存区域。")]),v._v(" "),a("blockquote",[a("p",[v._v("管理："),a("strong",[v._v("堆内存")]),v._v("存放了所有的"),a("strong",[v._v("对象实例和它们的实例变量")]),v._v("是垃圾收集器管理的主要区域。Java 的垃圾收集器会自动清理不再被引用的对象，释放内存空间。")])]),v._v(" "),a("h2",{attrs:{id:"java-内存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-内存管理"}},[v._v("#")]),v._v(" Java 内存管理")]),v._v(" "),a("p",[v._v("Java 的内存管理主要由垃圾收集器（Garbage Collector, GC）来执行，目的是自动监控和管理 JVM 中对象的创建和销毁。GC 通过识别和清理堆空间中不再使用的对象来防止内存泄漏。")]),v._v(" "),a("p",[v._v("垃圾收集算法：包括标记-清除（Mark-Sweep）、复制（Copying）、标记-整理（Mark-Compact）等。\n垃圾收集器：如 Serial、Parallel、CMS、G1 等，不同的收集器适用于不同类型和负载的应用。")]),v._v(" "),a("p",[v._v("注意这么几种形式:")]),v._v(" "),a("p",[v._v("1."),a("code",[v._v("数据类型 变量名")]),v._v(";")]),v._v(" "),a("ul",[a("li",[v._v("如果是基本数据类型就是普通的声明变量")])]),v._v(" "),a("ul",[a("li",[v._v('如果是引用数据类型,那就是这个变量名会去存储一个在堆内存中的对象的内存地址,这个变量名叫做"引用",并指向那个对象')])]),v._v(" "),a("blockquote",[a("p",[v._v("回顾：this 引用\n"),a("img",{attrs:{src:"https://ice2604-navi.github.io/assets/this.png",alt:""}})])]),v._v(" "),a("p",[v._v("2."),a("code",[v._v("new 类名();")]),v._v(" "),a("code",[v._v("new")]),v._v(" 后面的不是类名,而是通过调用那个类中的构造方法来创建对象!(返回值类型一定是它本身)")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("这是在创建了一个对象,并在堆内存中对象内存在各种属性.并且未赋值,且都为默认值!")]),v._v(" "),a("p",[v._v("3."),a("code",[v._v("变量名(对象名).变量名")])])]),v._v(" "),a("li",[a("p",[v._v("注意，最后访问到的可能是默认值，也可能是具体地址"),a("code",[v._v("n.name;")])]),v._v(" "),a("p",[v._v("4."),a("code",[v._v("u.name = new 类名();")])])]),v._v(" "),a("li",[a("p",[v._v("这种一定要注意最后等号左边一定是存放的是地址!!")]),v._v(" "),a("p",[v._v("5."),a("code",[v._v("数据类型 变量名 = new 类名();")])])]),v._v(" "),a("li",[a("p",[v._v("先关注变量名是局部变量(在栈内存中)还是成员变量.\n要注意这块其实本质就是赋地址的值!!!!")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);